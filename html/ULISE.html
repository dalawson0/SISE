<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>ULISE</title>
<meta name="generator" content="MATLAB 25.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-10-08">
<meta name="DC.source" content="ULISE.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#3">Initialization</a>
</li>
</ul>
</div>
<pre class="codeinput">
<span class="keyword">function</span> [xhat_UL,Px_UL,dhat_UL,Pd_UL,Pxd_UL] = ULISE(A,B,C,D,G,H,Q,R,K,u,y,xhat0,P_x0)
</pre>
<pre class="codeinput">
<span class="comment">% ULISE Unified Linear Input &amp; State Estimator (time-invariant)</span>
<span class="comment">%</span>
<span class="comment">%   Syntax:</span>
<span class="comment">%       [xhat_UL, Px_UL, dhat_UL, Pd_UL, Pxd_UL] = ULISE(A,B,C,D,G,H,Q,R,K,u,y,xhat0,P_x0)</span>
<span class="comment">%</span>
<span class="comment">%   Description:</span>
<span class="comment">%       ULISE computes minimum-variance, unbiased estimates of the state x_k</span>
<span class="comment">%       and unknown input (disturbance) d_k for a discrete-time, linear,</span>
<span class="comment">%       time-invariant system of the form:</span>
<span class="comment">%</span>
<span class="comment">%           x_{k+1} = A x_k + B u_k + G d_k + w_k   {State equation}</span>
<span class="comment">%           y_k     = C x_k + D u_k + H d_k + v_k   {Measurement equation}</span>
<span class="comment">%</span>
<span class="comment">%       where u_k is a known input, w_k is process noise, and v_k is measurement noise.</span>
<span class="comment">%       Optimal estimates are obtained as follows:</span>
<span class="comment">%</span>
<span class="comment">%       ULISE takes the state-space matrices A, B, C, D, G, H and the</span>
<span class="comment">%       covariance matrices:</span>
<span class="comment">%</span>
<span class="comment">%           Q = E{w_k w_k'} ,   R = E{v_k v_k'}.</span>
<span class="comment">%</span>
<span class="comment">%       The algorithm produces steady-state estimates of both the state and</span>
<span class="comment">%       unknown input, as well as their corresponding error covariances.</span>
<span class="comment">%</span>
<span class="comment">%   Inputs:</span>
<span class="comment">%       A,B,C,D,G,H : System matrices (time-invariant)</span>
<span class="comment">%       Q,R         : Process and measurement noise covariance matrices</span>
<span class="comment">%       K           : Kalman gain (if precomputed, optional)</span>
<span class="comment">%       u           : Known input sequence</span>
<span class="comment">%       y           : Measurement sequence</span>
<span class="comment">%       xhat0       : Initial state estimate</span>
<span class="comment">%       P_x0        : Initial error covariance</span>
<span class="comment">%</span>
<span class="comment">%   Outputs:</span>
<span class="comment">%       xhat_UL : Estimated state sequence</span>
<span class="comment">%       Px_UL   : State error covariance</span>
<span class="comment">%       dhat_UL : Estimated unknown input sequence</span>
<span class="comment">%       Pd_UL   : Unknown input error covariance</span>
<span class="comment">%       Pxd_UL  : Cross-covariance between state and input estimates</span>
<span class="comment">%</span>
<span class="comment">%   Notes:</span>
<span class="comment">%       &bull; Unobservable components of d_k (denoted d₂) are estimated one</span>
<span class="comment">%         time step later if rank(H) &ne; full rank.</span>
<span class="comment">%</span>
<span class="comment">%   See also:</span>
<span class="comment">%       &lt;matlab:helpwin('ULISE_algorithm_overview') ULISE Algorithm Overview&gt;</span>
<span class="comment">%</span>
<span class="comment">%   References:</span>
<span class="comment">%       [1] Yong, S.Z., Zhu, M., Frazzoli, E. (2015). "A unified filter for</span>
<span class="comment">%           simultaneous input and state estimation of linear discrete-time</span>
<span class="comment">%           stochastic systems." Automatica, 62, 321&ndash;329.</span>
<span class="comment">%       Extended version: http://arxiv.org/abs/1309.6627</span>
<span class="comment">%</span>
<span class="comment">%   Version History:</span>
<span class="comment">%       Introduced in SISE v1.0</span>

n=size(A,1);
l=size(C,1);
p=size(G,2);
r=rank(H);

<span class="comment">% Generate time steps</span>
k=1:K;

<span class="comment">% Coordinate transformation</span>
[U,S,V]=svd(H);
U1=U(:,1:r);
U2=U(:,r+1:end);
Sigma=S(1:r,1:r);
V1=V(:,1:r);
V2=V(:,r+1:end);
T1=[eye(r) -U1'*R*U2*inv(U2'*R*U2)]*[U1';U2'];
T2=U2';
C1=T1*C;
C2=T2*C;
D1=T1*D;
D2=T2*D;
G1=G*V1;
G2=G*V2;
M1=pinv(Sigma);
R1=T1*R*T1';
R2=T2*R*T2';
Ahat=A-G1*M1*C1;
Qhat=G1*M1*R1*M1'*G1'+Q;

<span class="comment">% Transmission zeros</span>
t_zeros = tzero(A,G,C,H)
<span class="keyword">if</span> rank([A G;C H]) ~= n+p
    error(<span class="string">'Error. System is not strongly detectable.'</span>)
<span class="keyword">end</span>
<span class="keyword">for</span> i = 1:length(t_zeros)
    <span class="keyword">if</span> abs(t_zeros(i))&gt;1
        error(<span class="string">'Error. System is not strongly detectable.'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> rank(C2*G2)&lt;p-r
    error(<span class="string">'Error. Delay greater or equal to 1. See: Yong, S.Z., Zhu, M., and Frazzoli, E. (2015). Simultaneous input and state estimation with a delay. IEEE Conference on Decision and Control, Osaka, Japan, pp. 468-475'</span>)
<span class="keyword">end</span>


<span class="comment">% Output decoupling</span>
z1=zeros(r,K);
z2=zeros(l-r,K);
<span class="keyword">for</span> i = 1:K
    z1(:,i)=T1*y(:,i);
    z2(:,i)=T2*y(:,i);
<span class="keyword">end</span>
</pre>
<h2 id="3">Initialization</h2>
<pre class="codeinput">
<span class="comment">% this is how you enable all algo to be efficient as you predetermine the</span>
<span class="comment">% size of each variable!</span>

xhat_UL=zeros(n,length(k));
xhat_p_UL=zeros(n,length(k));
xhat_star_UL=zeros(n,length(k));

dhat_UL=zeros(p,length(k));
Px_UL=zeros(n,n,length(k));
Pxd_UL=zeros(n,p,length(k));
Pd_UL=zeros(p,p,length(k));
Px_star_UL=zeros(n,n,length(k));
P_tilde_UL=zeros(n,n,length(k));

R1_tilde_UL=zeros(r,r,length(k));
R2_tilde_UL=zeros(l-r,l-r,length(k));
R2_tilde_star_UL=zeros(l-r,l-r,length(k));

Pd1_UL=zeros(r,r,length(k));
Pd2_UL=zeros(p-r,p-r,length(k));
Pd12_UL=zeros(r,p-r,length(k));
Pxd1_UL=zeros(n,r,length(k));
Pxd2_UL=zeros(n,p-r,length(k));

M_UL=zeros(p-r,l-r,length(k));
L_UL=zeros(n,l-r,length(k));

dhat1_UL=zeros(r,length(k));
dhat2_UL=zeros(p-r,length(k));

xhat_UL(:,1) = xhat0;
Px_UL(:,:,1) = P_x0;
dhat1_UL(:,1)=M1*(z1(:,1)-C1*xhat_UL(:,1)-D1*u(:,1));
Pd1_UL(:,:,1) = M1*(C1*Px_UL(:,:,1)*C1'+R1)*M1;
Pxd1_UL(:,:,1) = -Px_UL(:,:,1)*C1'*M1';

<span class="comment">% Filter dynamics (ULISE)</span>
<span class="keyword">for</span> i=k(1:end-1)
    <span class="comment">% Estimation of d2 and d</span>
    P_tilde_UL(:,:,i+1)=Ahat*Px_UL(:,:,i)*Ahat'+Qhat; <span class="comment">%(:,:,i) every row and column from the (k-1)th timestep matrix</span>
    R2_tilde_UL(:,:,i+1)=C2*P_tilde_UL(:,:,i+1)*C2'+R2;
    Pd2_UL(:,:,i)=inv(G2'*C2'*inv(R2_tilde_UL(:,:,i+1))*C2*G2);
    M_UL(:,:,i+1)=Pd2_UL(:,:,i)*G2'*C2'*inv(R2_tilde_UL(:,:,i+1));
    xhat_p_UL(:,i+1)=A*xhat_UL(:,i)+B*u(:,i)+G1*dhat1_UL(:,i);
    dhat2_UL(:,i)=M_UL(:,:,i+1)*(z2(:,i+1)-C2*xhat_p_UL(:,i+1)-D2*u(:,i+1));
    dhat_UL(:,i)=V*[dhat1_UL(:,i);dhat2_UL(:,i)];
    Pd12_UL(:,:,i)=-Pxd1_UL(:,:,i)'*A'*C2'*M_UL(:,:,i+1)'-Pd1_UL(:,:,i)*G1'*C2'*M_UL(:,:,i+1)';
    Pxd2_UL(:,:,i)=-Px_UL(:,:,i)*A'*C2'*M_UL(:,:,i+1)'-Pxd1_UL(:,:,i)*G1'*C2'*M_UL(:,:,i+1)';

    <span class="comment">% Time update (update the estimation of xhat)</span>
    xhat_star_UL(:,i+1)=xhat_p_UL(:,i+1)+G2*dhat2_UL(:,i);
    Px_star_UL(:,:,i+1)=G2*M_UL(:,:,i+1)*R2*M_UL(:,:,i+1)'*G2'+(eye(n)-G2*M_UL(:,:,i+1)*C2)*P_tilde_UL(:,:,i+1)*(eye(n)-G2*M_UL(:,:,i+1)*C2)';
    R2_tilde_star_UL(:,:,i+1)=C2*Px_star_UL(:,:,i+1)*C2'+R2-C2*G2*M_UL(:,:,i+1)*R2-R2*M_UL(:,:,i+1)'*G2'*C2';

    <span class="comment">% Measurement update</span>
    R_pinv=pinv(R2_tilde_star_UL(:,:,i+1));
    L_UL(:,:,i+1)=(Px_star_UL(:,:,i+1)*C2'-G2*M_UL(:,:,i+1)*R2)*R_pinv;
    xhat_UL(:,i+1)=xhat_star_UL(:,i+1)+L_UL(:,:,i+1)*(z2(:,i+1)-D2*u(i+1)-C2*xhat_star_UL(:,i+1));
    Px_UL(:,:,i+1)=(eye(n)-L_UL(:,:,i+1)*C2)*Px_star_UL(:,:,i+1)*(eye(n)-L_UL(:,:,i+1)*C2)'+L_UL(:,:,i+1)*R2*L_UL(:,:,i+1)'+L_UL(:,:,i+1)*R2*M_UL(:,:,i+1)'*G2'*(eye(n)-L_UL(:,:,i+1)*C2)'+(eye(n)-L_UL(:,:,i+1)*C2)*G2*M_UL(:,:,i+1)*R2*L_UL(:,:,i+1)';

    <span class="comment">% Estimation of d1</span>
    R1_tilde_UL(:,:,i+1)=C1*Px_UL(:,:,i+1)*C1'+R1;
    Pd1_UL(:,:,i+1)=M1*R1_tilde_UL(:,:,i+1)*M1;
    dhat1_UL(:,i+1)=M1*(z1(:,i+1)-C1*xhat_UL(:,i+1)-D1*u(:,i+1));
    Pxd1_UL(:,:,i+1)=-Px_UL(:,:,i+1)*C1'*M1';
    Pd_UL(:,:,i)=V*[Pd1_UL(:,:,i) Pd12_UL(:,:,i); Pd12_UL(:,:,i)' Pd2_UL(:,:,i)]*V';

    <span class="comment">% Estimation of Pxd</span>
    Pxd_UL(:,:,i)=Pxd1_UL(:,:,i)*V1'+Pxd2_UL(:,:,i)*V2';

    [norm((eye(n)-L_UL(:,:,i+1)*C2)*(eye(n)-G2*M_UL(:,:,i+1)*C2)*Ahat,1),norm((eye(n)-L_UL(:,:,i+1)*C2)*(eye(n)-G2*M_UL(:,:,i+1)*C2)*Ahat,2),norm((eye(n)-L_UL(:,:,i+1)*C2)*(eye(n)-G2*M_UL(:,:,i+1)*C2)*Ahat,inf),norm((eye(n)-L_UL(:,:,i+1)*C2)*(eye(n)-G2*M_UL(:,:,i+1)*C2)*Ahat,<span class="string">'fro'</span>),norm((eye(n)-L_UL(:,:,i+1)*C2)*(eye(n)-G2*M_UL(:,:,i+1)*C2)*Ahat,<span class="string">'fro'</span>)];
<span class="keyword">end</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2025b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
function [xhat_UL,Px_UL,dhat_UL,Pd_UL,Pxd_UL] = ULISE(A,B,C,D,G,H,Q,R,K,u,y,xhat0,P_x0)
% ULISE Unified Linear Input & State Estimator (time-invariant)
%
%   Syntax:
%       [xhat_UL, Px_UL, dhat_UL, Pd_UL, Pxd_UL] = ULISE(A,B,C,D,G,H,Q,R,K,u,y,xhat0,P_x0)
%
%   Description:
%       ULISE computes minimum-variance, unbiased estimates of the state x_k
%       and unknown input (disturbance) d_k for a discrete-time, linear,
%       time-invariant system of the form:
%
%           x_{k+1} = A x_k + B u_k + G d_k + w_k   {State equation}
%           y_k     = C x_k + D u_k + H d_k + v_k   {Measurement equation}
%
%       where u_k is a known input, w_k is process noise, and v_k is measurement noise.
%       Optimal estimates are obtained as follows:
%
%       ULISE takes the state-space matrices A, B, C, D, G, H and the
%       covariance matrices:
%
%           Q = E{w_k w_k'} ,   R = E{v_k v_k'}.
%
%       The algorithm produces steady-state estimates of both the state and
%       unknown input, as well as their corresponding error covariances.
%
%   Inputs:
%       A,B,C,D,G,H : System matrices (time-invariant)
%       Q,R         : Process and measurement noise covariance matrices
%       K           : Kalman gain (if precomputed, optional)
%       u           : Known input sequence
%       y           : Measurement sequence
%       xhat0       : Initial state estimate
%       P_x0        : Initial error covariance
%
%   Outputs:
%       xhat_UL : Estimated state sequence
%       Px_UL   : State error covariance
%       dhat_UL : Estimated unknown input sequence
%       Pd_UL   : Unknown input error covariance
%       Pxd_UL  : Cross-covariance between state and input estimates
%
%   Notes:
%       • Unobservable components of d_k (denoted d₂) are estimated one
%         time step later if rank(H) ≠ full rank.
%
%   See also:
%       <matlab:helpwin('ULISE_algorithm_overview') ULISE Algorithm Overview>
%
%   References:
%       [1] Yong, S.Z., Zhu, M., Frazzoli, E. (2015). "A unified filter for
%           simultaneous input and state estimation of linear discrete-time
%           stochastic systems." Automatica, 62, 321–329.
%       Extended version: http://arxiv.org/abs/1309.6627
%
%   Version History:
%       Introduced in SISE v1.0

n=size(A,1);
l=size(C,1);
p=size(G,2);
r=rank(H);

% Generate time steps
k=1:K;

% Coordinate transformation
[U,S,V]=svd(H);
U1=U(:,1:r);
U2=U(:,r+1:end);
Sigma=S(1:r,1:r);
V1=V(:,1:r);
V2=V(:,r+1:end);
T1=[eye(r) -U1'*R*U2*inv(U2'*R*U2)]*[U1';U2'];
T2=U2';
C1=T1*C;
C2=T2*C;
D1=T1*D;
D2=T2*D;
G1=G*V1;
G2=G*V2;
M1=pinv(Sigma);
R1=T1*R*T1';
R2=T2*R*T2';
Ahat=A-G1*M1*C1;
Qhat=G1*M1*R1*M1'*G1'+Q;

% Transmission zeros
t_zeros = tzero(A,G,C,H)
if rank([A G;C H]) ~= n+p
    error('Error. System is not strongly detectable.')
end
for i = 1:length(t_zeros)
    if abs(t_zeros(i))>1
        error('Error. System is not strongly detectable.')
    end
end
if rank(C2*G2)<p-r
    error('Error. Delay greater or equal to 1. See: Yong, S.Z., Zhu, M., and Frazzoli, E. (2015). Simultaneous input and state estimation with a delay. IEEE Conference on Decision and Control, Osaka, Japan, pp. 468-475')
end


% Output decoupling
z1=zeros(r,K);
z2=zeros(l-r,K);
for i = 1:K
    z1(:,i)=T1*y(:,i);
    z2(:,i)=T2*y(:,i);
end

%% Initialization

% this is how you enable all algo to be efficient as you predetermine the
% size of each variable!

xhat_UL=zeros(n,length(k));
xhat_p_UL=zeros(n,length(k));
xhat_star_UL=zeros(n,length(k));

dhat_UL=zeros(p,length(k));
Px_UL=zeros(n,n,length(k));
Pxd_UL=zeros(n,p,length(k));
Pd_UL=zeros(p,p,length(k));
Px_star_UL=zeros(n,n,length(k));
P_tilde_UL=zeros(n,n,length(k));

R1_tilde_UL=zeros(r,r,length(k));
R2_tilde_UL=zeros(l-r,l-r,length(k));
R2_tilde_star_UL=zeros(l-r,l-r,length(k));

Pd1_UL=zeros(r,r,length(k));
Pd2_UL=zeros(p-r,p-r,length(k));
Pd12_UL=zeros(r,p-r,length(k));
Pxd1_UL=zeros(n,r,length(k));
Pxd2_UL=zeros(n,p-r,length(k));

M_UL=zeros(p-r,l-r,length(k));
L_UL=zeros(n,l-r,length(k));

dhat1_UL=zeros(r,length(k));
dhat2_UL=zeros(p-r,length(k));

xhat_UL(:,1) = xhat0;
Px_UL(:,:,1) = P_x0;
dhat1_UL(:,1)=M1*(z1(:,1)-C1*xhat_UL(:,1)-D1*u(:,1));
Pd1_UL(:,:,1) = M1*(C1*Px_UL(:,:,1)*C1'+R1)*M1;
Pxd1_UL(:,:,1) = -Px_UL(:,:,1)*C1'*M1';

% Filter dynamics (ULISE)
for i=k(1:end-1)
    % Estimation of d2 and d
    P_tilde_UL(:,:,i+1)=Ahat*Px_UL(:,:,i)*Ahat'+Qhat; %(:,:,i) every row and column from the (k-1)th timestep matrix
    R2_tilde_UL(:,:,i+1)=C2*P_tilde_UL(:,:,i+1)*C2'+R2;
    Pd2_UL(:,:,i)=inv(G2'*C2'*inv(R2_tilde_UL(:,:,i+1))*C2*G2);
    M_UL(:,:,i+1)=Pd2_UL(:,:,i)*G2'*C2'*inv(R2_tilde_UL(:,:,i+1));
    xhat_p_UL(:,i+1)=A*xhat_UL(:,i)+B*u(:,i)+G1*dhat1_UL(:,i);
    dhat2_UL(:,i)=M_UL(:,:,i+1)*(z2(:,i+1)-C2*xhat_p_UL(:,i+1)-D2*u(:,i+1));
    dhat_UL(:,i)=V*[dhat1_UL(:,i);dhat2_UL(:,i)];
    Pd12_UL(:,:,i)=-Pxd1_UL(:,:,i)'*A'*C2'*M_UL(:,:,i+1)'-Pd1_UL(:,:,i)*G1'*C2'*M_UL(:,:,i+1)';
    Pxd2_UL(:,:,i)=-Px_UL(:,:,i)*A'*C2'*M_UL(:,:,i+1)'-Pxd1_UL(:,:,i)*G1'*C2'*M_UL(:,:,i+1)';
    
    % Time update (update the estimation of xhat)
    xhat_star_UL(:,i+1)=xhat_p_UL(:,i+1)+G2*dhat2_UL(:,i);
    Px_star_UL(:,:,i+1)=G2*M_UL(:,:,i+1)*R2*M_UL(:,:,i+1)'*G2'+(eye(n)-G2*M_UL(:,:,i+1)*C2)*P_tilde_UL(:,:,i+1)*(eye(n)-G2*M_UL(:,:,i+1)*C2)'; 
    R2_tilde_star_UL(:,:,i+1)=C2*Px_star_UL(:,:,i+1)*C2'+R2-C2*G2*M_UL(:,:,i+1)*R2-R2*M_UL(:,:,i+1)'*G2'*C2';
    
    % Measurement update
    R_pinv=pinv(R2_tilde_star_UL(:,:,i+1));
    L_UL(:,:,i+1)=(Px_star_UL(:,:,i+1)*C2'-G2*M_UL(:,:,i+1)*R2)*R_pinv;
    xhat_UL(:,i+1)=xhat_star_UL(:,i+1)+L_UL(:,:,i+1)*(z2(:,i+1)-D2*u(i+1)-C2*xhat_star_UL(:,i+1));
    Px_UL(:,:,i+1)=(eye(n)-L_UL(:,:,i+1)*C2)*Px_star_UL(:,:,i+1)*(eye(n)-L_UL(:,:,i+1)*C2)'+L_UL(:,:,i+1)*R2*L_UL(:,:,i+1)'+L_UL(:,:,i+1)*R2*M_UL(:,:,i+1)'*G2'*(eye(n)-L_UL(:,:,i+1)*C2)'+(eye(n)-L_UL(:,:,i+1)*C2)*G2*M_UL(:,:,i+1)*R2*L_UL(:,:,i+1)';
    
    % Estimation of d1
    R1_tilde_UL(:,:,i+1)=C1*Px_UL(:,:,i+1)*C1'+R1;
    Pd1_UL(:,:,i+1)=M1*R1_tilde_UL(:,:,i+1)*M1;
    dhat1_UL(:,i+1)=M1*(z1(:,i+1)-C1*xhat_UL(:,i+1)-D1*u(:,i+1));
    Pxd1_UL(:,:,i+1)=-Px_UL(:,:,i+1)*C1'*M1';
    Pd_UL(:,:,i)=V*[Pd1_UL(:,:,i) Pd12_UL(:,:,i); Pd12_UL(:,:,i)' Pd2_UL(:,:,i)]*V';
    
    % Estimation of Pxd
    Pxd_UL(:,:,i)=Pxd1_UL(:,:,i)*V1'+Pxd2_UL(:,:,i)*V2';
    
    [norm((eye(n)-L_UL(:,:,i+1)*C2)*(eye(n)-G2*M_UL(:,:,i+1)*C2)*Ahat,1),norm((eye(n)-L_UL(:,:,i+1)*C2)*(eye(n)-G2*M_UL(:,:,i+1)*C2)*Ahat,2),norm((eye(n)-L_UL(:,:,i+1)*C2)*(eye(n)-G2*M_UL(:,:,i+1)*C2)*Ahat,inf),norm((eye(n)-L_UL(:,:,i+1)*C2)*(eye(n)-G2*M_UL(:,:,i+1)*C2)*Ahat,'fro'),norm((eye(n)-L_UL(:,:,i+1)*C2)*(eye(n)-G2*M_UL(:,:,i+1)*C2)*Ahat,'fro')];
end 

##### SOURCE END #####
-->
</body>
</html>
